# Ruta de madurez profesional

## 1. Nivel 0 — Aprendiendo

1. Computación y sistemas
    1. Fundamentos de sistemas tipo Unix (2.1.1)
    2. Comandos esenciales de línea de comando (2.1.2)
    3. Gestión de paquetes y entornos del sistema (2.1.3)
    4. Variables de entorno y configuración (2.1.5)
    5. Personalización del entorno de trabajo (2.1.10)
    6. Estructuras lineales: listas, pilas, colas, colas dobles (3.2.3)
    7. Sintaxis y estructuras básicas (2.2.3)
    8. Tipos de datos y abstracción de datos (2.2.4)
    9. Control de flujo (condicionales, bucles, manejo de ramificaciones) (2.2.5)
    10. Organización en módulos y paquetes (2.2.9)
    11. Manejo básico de repositorios: fundamentos de control de versiones distribuido (2.4.1)

2. Práctica del desarrollador
    1. Sintaxis y estructuras básicas (2.2.3)
    2. Tipos de datos y abstracción de datos (2.2.4)
    3. Control de flujo (condicionales, bucles, manejo de ramificaciones) (2.2.5)
    4. Funciones, cierres y paso de datos (2.2.6)
    5. Programación orientada a objetos (clases, interfaces, herencia, composición) (2.2.8)
    6. Manejo de errores y excepciones (2.2.11)
    7. Iteradores, generadores y secuencias consumibles (2.2.13)
    8. Serialización y deserialización de estructuras (2.2.15)
    9. Estilo, convenciones y mantenibilidad del código (2.2.16)
    10. Plantillas de proyectos y generación de esqueletos de servicio (2.3.3)
    11. Ejecutores de tareas y automatización repetible (scripts, makefiles, job runners) (2.3.4)
    12. Integración y configuración del editor/IDE (2.3.7)
    13. Formateo automático y validaciones previas al commit (2.3.10)
    14. Estrategias de ramificación básicas (trunk-based / release branches) (2.4.2)
    15. Resolución de conflictos (2.4.4)
    16. Convenciones de commits y gestión semántica de versiones (2.4.5)
    17. Versionado semántico y etiquetado de lanzamientos (2.4.6)
    18. Integración con revisión de código e integración continua (2.4.9)

3. Diseño y software
    1. Principios de diseño orientado a mantenibilidad (3.1.1)
    2. Evitar repetición innecesaria y mantener la simplicidad (3.1.2)
    3. Complejidad temporal y espacial (notación asintótica) (3.2.1)
    4. Algoritmos de ordenamiento y búsqueda (3.2.7)
    5. Recursividad y divide y vencerás (3.2.8)
    6. Requisitos de software (3.3.1)
    7. Construcción y estándares de codificación (3.3.4)
    8. Verificación y validación: introducción (3.3.5)

4. Backend y servicios
    1. Tipos y arquitecturas web (4.1.1)
    2. Validación y serialización de datos de entrada y salida (4.1.4)
    3. Especificaciones y documentación de APIs (contratos máquina-legibles) (4.1.8)
    4. Lenguajes de consulta estructurados (4.2.1)
    5. Modelado relacional (4.2.2)
    6. Normalización y desnormalización (4.2.3)
    7. Mapeo objeto–relacional y capas de acceso a datos (4.2.7)
    8. Migraciones estructuradas y controladas de esquema (4.2.8)
    9. Webhooks, notificaciones y callbacks externos (4.3.3)
    10. Integración con servicios de terceros (4.3.4)

5. Datos y ML
    1. Manipulación y transformación de datos (7.2.2)
    2. Limpieza, imputación, normalización y validación de datos (7.2.3)
    3. Análisis exploratorio de datos y visualización básica (7.2.11)
    4. Fundamentos de probabilidad y estadística básica (7.1.5)

6. Seguridad
    1. Sanitización y validación de entrada (8.1.9)
    2. Principales vectores de ataque en aplicaciones web (8.1.1)

7. Calidad y auditoría
    1. Pruebas unitarias (9.2.1)
    2. Pruebas de integración (9.2.2)
    3. Pruebas basadas en instantáneas y estados esperados (9.2.5)
    4. Simulación de dependencias y dobles de prueba (9.2.6)
    5. Métricas de cobertura y criterios de calidad (9.2.8)
    6. Análisis estático y linters (9.2.9)

## 2. Nivel 1 — Junior

1. Computación y sistemas
    1. Arquitectura de computadores (1.2)
    2. Redes y protocolos (1.6)
    3. Modelos cliente-servidor y peer-to-peer (1.7)
    4. Computación en la nube y edge computing (1.11)
    5. Virtualización y contenedorización (1.4)

2. Práctica del desarrollador
    1. Servicios del sistema, tareas programadas y demonios (2.1.4)
    2. Supervisión de procesos y recursos (2.1.6)
    3. Redes y puertos (2.1.7)
    4. Seguridad y control de acceso a nivel de sistema (2.1.8)
    5. Automatización y scripting en la línea de comando (2.1.9)
    6. Documentación viva y navegable (2.3.5)
    7. Perfilado y depuración interactiva (2.3.8)
    8. Chequeo estático de tipos y análisis estático (2.3.9)
    9. Plantillas de integración continua y entrega continua (2.3.11)
    10. Entornos de desarrollo reproducibles y remotos (2.3.12)
    11. Integración con revisión de código e integración continua (2.4.9)
    12. Políticas de revisión y ramas protegidas (2.4.10)
    13. Auditoría del historial y trazabilidad de cambios (2.4.11)

3. Diseño y software
    1. Patrones de diseño (creacionales, estructurales y de comportamiento) (3.1.3)
    2. Arquitectura en capas (3.1.4)
    3. Complejidad y análisis de eficiencia algorítmica (3.2.2)
    4. Árboles, montículos, tries y estructuras jerárquicas (3.2.4)
    5. Hashing y tablas hash (3.2.6)
    6. Requisitos → análisis y trazabilidad (3.3.2)
    7. Diseño de software (3.3.3)
    8. Ingeniería de calidad de software: fundamentos (3.3.8)
    9. Procesos de desarrollo (3.3.9)
    10. Herramientas de soporte al ciclo de vida del software (3.3.11)

4. Backend y servicios
    1. Comunicación bidireccional y tiempo real (sockets, streaming) (4.1.2)
    2. Middleware, interceptores y filtros (4.1.3)
    3. Autenticación y autorización a nivel de servicio (4.1.5)
    4. Índices, vistas y disparadores (4.2.5)
    5. Procedimientos almacenados y lógica en base de datos (4.2.6)

5. Datos y ML
    1. Álgebra lineal para datos y modelos (7.1.1)
    2. Muestreo, estimación e inferencia estadística (7.1.6)
    3. Diseño experimental y significancia estadística (7.3.4)
    4. Series temporales básicas: agregaciones y ventanas de tiempo (7.2.5)
    5. Métricas de negocio y definición de KPI (7.2.6)
    6. Segmentación, cohortes y comportamiento de usuarios (7.2.7)
    7. Storytelling con datos y comunicación ejecutiva (7.2.12)

6. Seguridad
    1. Autenticación y autorización (incluyendo federación de identidad y SSO) (8.1.5)
    2. Seguridad en bases de datos y control de acceso a datos sensibles (8.1.7)
    3. Registro de eventos de seguridad y trazabilidad (8.1.8)
    4. Gestión de sesiones y mitigación de secuestro de sesión (8.1.11)
    5. Política de mínimo privilegio en componentes internos (8.1.12)

7. Calidad y auditoría
    1. Pruebas de contrato entre servicios (9.2.4)
    2. Análisis de seguridad automatizado (9.2.10)
    3. Ejecución automática de pruebas en pipelines de entrega (9.2.11)
    4. Integración continua y despliegue continuo (9.3.1)
    5. Control de versiones de dependencias externas (9.3.2)
    6. Revisión de código estructurada y guías internas (9.3.3)
    7. Estándares de codificación y criterios de aprobación (9.3.8)

## 3. Nivel 2 — Intermedio

1. Computación y sistemas
    1. Autómatas y modelos de cómputo (1.1)
    2. Sistemas operativos (procesos, hilos, memoria, planificación) (1.3)
    3. Algoritmos distribuidos (1.9)

2. Práctica del desarrollador
    1. Lenguajes formales y gramáticas (1.1.4)
    2. Semántica y diseño de lenguajes (2.2.2)
    3. Compilación e interpretación (2.2.1)
    4. Tipado estático y anotaciones de tipo (2.2.10)
    5. Gestión estructurada de recursos (scopes y contextos controlados) (2.2.12)
    6. Metaprogramación y reflexión (2.2.14)
    7. Documentación viva y navegable (automatizada) (2.3.5)
    8. CLI internas para flujos (2.3.6)
    9. Perfilado y depuración interactiva avanzada (2.3.8)
    10. Rebase, merge, cherry-pick y trabajo en paralelo (2.4.3)
    11. Submódulos, monorepos y multi-repos (2.4.7)
    12. Hooks y automatización del flujo de trabajo (2.4.8)

3. Diseño y software
    1. Programación dinámica y memoización (3.2.9)
    2. Grafos (3.2.5)
    3. Algoritmos probabilísticos y aproximados (3.2.12)
    4. Algoritmos de concurrencia y sincronización (3.2.10)
    5. Estructuras inmutables/persistentes (3.2.11)
    6. Ingeniería de calidad de software (planificación/verificación) (3.3.8)
    7. Métricas de productividad y calidad del software (3.3.10)
    8. Mejora continua de procesos y madurez operativa (3.3.12)

4. Backend y servicios
    1. Transacciones, atomicidad y aislamiento (4.2.4)
    2. Pools de conexiones y acceso concurrente (4.2.9)
    3. Almacenamiento no relacional (4.2.10)
    4. Motores de búsqueda y texto libre (4.2.11)

5. Datos y ML
    1. Modelos descriptivos (qué pasó) (7.6.8)
    2. Modelos de diagnóstico (por qué pasó) (7.6.8)
    3. Fundamentos de aprendizaje supervisado y no supervisado (7.4.1)
    4. Modelos clásicos de ML (regresión, árboles, ensembles, boosting) (7.5.1)
    5. Regularización y control de sobreajuste (7.4.3)
    6. Evaluación, validación cruzada y partición de datos (7.6.1)
    7. Métricas de clasificación, regresión y ranking (7.6.2)

6. Seguridad
    1. Protección contra inyecciones, XSS, CSRF, etc. (8.1.4)
    2. Criptografía práctica y hashing seguro (8.1.2)
    3. Canales seguros y certificados (cifrado en tránsito) (8.1.3)

7. Calidad y auditoría
    1. Pruebas de aceptación y regresión (9.3.7)
    2. Documentación de calidad y trazabilidad (9.3.10)

## 4. Nivel 3 — Semi Senior

1. Computación y sistemas
    1. Consistencia y tolerancia a fallos (1.8)
    2. Computación paralela y vectorizada (1.10)
    3. Balanceo de carga y redes de distribución de contenido (CDN) (1.13)
    4. Modelos de escalabilidad (1.14)

2. Práctica del desarrollador
    1. Diagnóstico de rendimiento (2.1.11)
    2. Auditoría del sistema y logs (2.1.12)

3. Diseño y software
    1. Arquitectura limpia (3.1.5)
    2. Arquitectura hexagonal (puertos/adaptadores) (3.1.6)
    3. Monolitos modulares y microservicios (3.1.8)

4. Backend y servicios
    1. Rate limiting, paginación y control de abuso (4.1.6)
    2. Versionado de APIs (4.1.7)
    3. Reintentos y colas de mensajes muertos (DLQ) (4.3.5)
    4. Serialización binaria y formatos compactos (4.3.6)
    5. Publicación/suscripción (4.3.8)
    6. Mensajería asíncrona y colas (4.3.1)
    7. RPC eficiente y contratos binarios (4.3.2)

5. Datos y ML
    1. Análisis causal y correlación vs causalidad (7.3.9)
    2. Analítica de producto y telemetría de uso (7.2.8)
    3. Análisis geoespacial y con localización (7.2.9)
    4. Forecasting de demanda / series temporales (7.5.14)
    5. Segmentación de usuarios y clustering (7.5.9)
    6. Recomendadores básicos (filtrado colaborativo clásico) (7.14.2)
    7. Detección de outliers y ruido (7.5.12)
    8. Reducción de dimensionalidad (7.5.11)
    9. Series temporales con ML tradicional (7.5.13)
    10. AutoML y búsqueda de hiperparámetros (7.5.15)
    11. Aprendizaje por refuerzo (visión general de MDP, recompensa, política) (7.13.1)
    12. Redes neuronales y modelos profundos (7.7.1)

6. Seguridad
    1. Modelado de amenazas y pruebas básicas de penetración (8.1.10)
    2. Aislamiento entre servicios y entornos (producción, staging, desarrollo) (8.2.1)
    3. Protección de datos en reposo (cifrado en disco y por objeto) (8.2.6)
    4. Gestión de parches y actualizaciones de seguridad (8.2.9)
    5. IAM, MFA y rotación periódica de credenciales (8.3.1)
    6. Auditoría de accesos (quién accede a qué y cuándo) (8.3.6)
    7. Revocación y desactivación segura de accesos (8.3.9)

7. Operación en producción
    1. Modelos asíncronos y bucles de eventos (10.1.1)
    2. Paralelismo con hilos y procesos (10.1.2)
    3. Tareas diferidas y trabajo en segundo plano (10.1.3)
    4. Futuros y promesas (10.1.4)
    5. Caching en memoria y distribuido (10.1.5)
    6. Perfilado de CPU y memoria (10.1.6)
    7. Cuellos de E/S vs cómputo (10.1.7)
    8. Benchmarking (10.1.8)
    9. Colas de trabajo y orquestadores (10.1.10)
    10. Logging estructurado y contextualizado (10.3.1)
    11. APM (monitoreo del desempeño de las aplicaciones) (10.3.2)
    12. Métricas personalizadas y verificaciones de salud (health checks) (10.3.4)
    13. Alertas basadas en umbrales y tendencias (10.3.5)
    14. Monitoreo de infraestructura y paneles de visualización (10.2.6)
    15. Plataformas en la nube (cómputo, redes, almacenamiento) (10.2.8)
    16. Almacenamiento de objetos, serverless y monitoreo gestionado (10.2.9)
    17. Monitoreo activo y alertas operacionales (10.2.11)

8. Calidad y auditoría
    1. Pruebas end-to-end (9.2.3)
    2. Pruebas basadas en propiedades (9.2.7)
    3. Integración continua y despliegue continuo en pipelines (9.3.1)
    4. QA/QC (aseguramiento y control de calidad) (9.3.5)
    5. Documentación de calidad y trazabilidad (9.3.10)
    6. Evaluaciones post-lanzamiento y mantenimiento preventivo (9.3.12)

## 5. Nivel 4 — Senior

1. Computación y sistemas
    1. Almacenamiento distribuido y sistemas de archivos (1.5)

2. Diseño y software
    1. Diseño guiado por el dominio (Domain-Driven Design) (3.1.7)
    2. Arquitecturas dirigidas por eventos (3.1.9)
    3. Versionado de interfaces y ciclos de vida de APIs (3.1.10)
    4. Modularización y empaquetado de componentes reutilizables (3.1.12)
    5. Ingeniería de calidad de software (madurez y métricas) (3.3.10)
    6. Mejora continua y madurez operativa (3.3.12)

3. Backend y servicios
    1. Almacenamiento analítico y sistemas orientados a BI (4.2.12)
    2. Integridad referencial y consistencia eventual (4.2.14)
    3. Event sourcing (4.3.7)
    4. Streaming de datos y captura de cambios (4.3.9)
    5. Patrones de microservicios (4.4.1)
    6. Descubrimiento de servicios y enrutamiento (4.4.2)

4. Datos y ML
    1. Análisis de riesgos, fraude y anomalías (7.2.10)
    2. Modelos prescriptivos (qué deberíamos hacer) (7.6.8)
    3. Evaluación de impacto y uplift (7.3.10)
    4. PLN y embeddings (7.10.1)
    5. Recuperación aumentada con contexto y búsqueda semántica (7.10.6)
    6. Recomendación avanzada y personalización en tiempo real (7.14.5)
    7. Serving e inferencia en producción (batch / tiempo real) (7.17.4)
    8. Integración de modelos en el flujo de negocio (automatización de decisiones en línea) (7.20.10)
    9. Ciclo de vida de modelos: entrenamiento, versionado, despliegue, rollback (7.17.1)
    10. Feature stores (7.17.3)
    11. Monitorización de deriva y degradación de modelos (7.17.6)
    12. Observabilidad de modelos (latencia, throughput, costo por predicción) (7.17.10)

5. Ingeniería de datos y plataformas
    1. Modelado analítico orientado a negocio (7.15.1)
    2. Modelado dimensional (7.15.2)
    3. Warehousing y lakehouses de datos (7.15.3)
    4. Catálogo de datos, linaje y descubribilidad (7.15.5)
    5. Integración con BI y tableros (7.15.8)
    6. Exposición de datos como servicio (APIs analíticas) (7.15.9)
    7. ETL/ELT (7.15.10)
    8. Orquestación de tareas y flujos (7.15.13)
    9. Formatos columnar y orientados a análisis (7.15.4)
    10. Gobernanza de acceso a datos y permisos (7.15.6)
    11. Retención, archivado y ciclo de vida de los datos (7.15.7)

6. Seguridad
    1. Hardening de sistemas operativos, contenedores y runtimes (8.2.2)
    2. Seguridad en redes: segmentación interna, firewalls, zonas de confianza (8.2.3)
    3. Control de tráfico interno (mTLS, políticas de red, service mesh) (8.2.4)
    4. Seguridad en la nube: configuración segura de recursos gestionados (8.2.5)
    5. Escaneo de vulnerabilidades en dependencias, imágenes y artefactos (8.2.8)
    6. Delegación de permisos y roles granulares (8.3.4)
    7. Acceso just-in-time y acceso de emergencia (8.3.5)

7. Operación en producción
    1. Escalado horizontal y vertical (10.1.9)
    2. Control de tasa y mecanismos de alivio de presión (10.1.11)
    3. Estrategias avanzadas de control de versiones y ramas (10.2.1)
    4. CI/CD en entornos reales (10.2.2)
    5. Despliegue de múltiples servicios coordinados (10.2.4)
    6. Orquestación de contenedores y planificación de cargas (10.2.5)
    7. Infraestructura como código (10.2.7)
    8. Gestión de configuración y secretos centralizados (10.2.10)
    9. Trazas distribuidas de extremo a extremo (10.3.3)
    10. Auditoría y reconstrucción de incidentes (10.3.6)
    11. Tolerancia a fallos y aislamiento (10.4.1)
    12. Control de latencia y tiempos de espera (10.4.2)
    13. Reintentos seguros (10.4.3)
    14. Protección contra sobrecarga (10.4.4)
    15. Salud del servicio y autosanación (10.4.5)
    16. Recuperación y continuidad (10.4.6)

8. Gestión técnica
    1. Estándares internos de código y guías (11.1.6)
    2. Comunicación con producto y otros equipos (11.1.7)
    3. Planificación de iteraciones y lanzamientos (11.1.8)
    4. Cultura de documentación viva (11.1.11)
    5. Inclusión, colaboración y seguridad psicológica (11.1.12)
    6. Gestión de proyectos (11.2.1)
    7. Estimación de esfuerzo y planificación técnica (11.2.2)
    8. Gestión de releases y control de cambios (11.2.5)
    9. Comunicación transversal (producto, QA, operaciones, datos) (11.2.6)

9. Calidad y auditoría
    1. Pruebas no funcionales (rendimiento, carga, resiliencia) (9.3.9)
    2. Métricas de calidad operacional (densidad de defectos, etc.) (9.3.6)

10. Cumplimiento y mejora
    1. Accesibilidad e inclusión en diseño y UX (12.1.7)
    2. Gobernanza de software libre y colaboración abierta (12.1.8)
    3. Reproducibilidad técnica y científica (12.1.10)
    4. Evaluación crítica de nuevas tecnologías (12.2.1)
    5. Prototipos rápidos y pruebas de concepto (12.2.2)
    6. Benchmarking técnico (12.2.3)
    7. Observación de tendencias tecnológicas y estado del arte (12.2.4)
    8. Comunidades técnicas y proyectos abiertos (12.2.5)
    9. Planes de aprendizaje continuo y formación técnica (12.2.8)
    10. Métricas de entrega y flujo de trabajo (12.3.1)
    11. Métricas de confiabilidad y disponibilidad (12.3.2)
    12. Métricas de calidad de código (12.3.3)
    13. Ciclo de retroalimentación con clientes y stakeholders (12.3.7)
    14. Gestión de backlog de mejoras operativas (12.3.9)

## 6. Nivel 5 — Staff

1. Datos, ML y plataformas
    1. MLOps / LLMOps: automatización del ciclo de vida de entrenamiento, despliegue y rollback (7.17.1)
    2. SLOs y SLAs para servicios de inferencia (7.17.11)
    3. Pipelines reproducibles y declarativos (ETL / ELT) (7.15.10)
    4. Optimización y perfilado de pipelines de datos (7.15.14)
    5. Pruebas de calidad de datos y contratos de datos (SLAs de datos) (7.15.15)
    6. Versionado de datos y de esquemas (linaje y reproducibilidad de datasets) (7.2.4)

2. Seguridad
    1. Seguridad de la cadena de suministro de software (supply chain security) (8.2.7)
    2. Detección de escalamiento lateral interno (8.4.7)
    3. Señales tempranas de compromiso en entornos críticos (8.4.8)
    4. Plan de respuesta a incidentes de seguridad (8.5.1)
    5. Contención, erradicación y recuperación (8.5.2)
    6. Postmortems de seguridad sin cultura de culpa (8.5.4)
    7. Cultura de seguridad: concientización y formación continua (8.6.8)
    8. Políticas internas de seguridad y uso aceptable (8.6.1)
    9. Clasificación y manejo de datos sensibles (8.6.2)
    10. Revisión periódica de riesgos y exposiciones (8.6.4)
    11. Evaluación de terceros y proveedores (8.6.5)
    12. Controles preventivos y controles compensatorios (8.6.6)

3. Operación y fiabilidad
    1. SRE interno y propiedad de servicio (11.3.1)
    2. Observabilidad organizacional (11.3.2)
    3. Gestión de alertas y fatiga de alarmas (11.3.4)
    4. Ciclos de despliegue seguro (11.3.5)
    5. Gestión de entornos (dev, staging, prod) (11.3.6)
    6. Controles de cambio y auditoría operativa (11.3.7)

4. Gestión técnica y liderazgo
    1. Gestión de deuda técnica (11.1.2)
    2. Mentoría y liderazgo técnico (11.1.3)
    3. Respuesta a incidentes en producción (11.1.4)
    4. Postmortems y análisis de causa raíz sin culpas (11.1.5)
    5. Evaluación de decisiones técnicas y trade-offs (11.1.9)
    6. Hoja de ruta técnica y visión de plataforma (11.1.10)
    7. Desarrollo profesional y mentoría técnica (11.2.7)
    8. Evaluación de desempeño técnico (11.2.8)
    9. Registro y documentación de decisiones de arquitectura (11.2.9)
    10. Presentación técnica a audiencias no técnicas (11.2.10)
    11. Cultura de ingeniería basada en aprendizaje continuo (11.2.11)
    12. Prácticas de mejora continua tras incidentes (11.2.12)
    13. Gestión de capacidad y asignación de recursos (11.2.13)

5. Calidad, cumplimiento y mejora
    1. Auditorías de seguridad y cumplimiento normativo (9.3.4)
    2. Cumplimiento de marcos y certificaciones de la industria (9.3.11)
    3. Privacidad y manejo responsable de datos (12.1.2)
    4. Responsabilidad profesional en ingeniería de software (12.1.1)
    5. Protección de datos personales y trazabilidad de acceso (12.1.9)
    6. Comunicación honesta y responsable con stakeholders (12.1.11)
    7. Innovación responsable, segura y sostenible (12.2.10)
    8. Cultura de experimentación y “hack time” (12.2.13)
    9. Procesos de mejora continua tipo Kaizen (12.3.6)
    10. Transparencia interna y reportes ejecutivos (12.3.11)

## 7. Nivel 6 — Tech Lead / Arquitecto / Head of Engineering

1. Estrategia organizacional y cumplimiento
    1. Regulaciones y marcos legales aplicables (12.1.4)
    2. Evaluación de impacto social y de riesgo operacional (12.1.12)
    3. Gobernanza del ciclo de vida completo del dato y del modelo (7.19.11)
    4. Políticas internas de aprobación y revisión humana obligatoria (7.19.12)
    5. Sostenibilidad y costo energético de cómputo en IA (7.18.7)
    6. Continuidad operativa y resiliencia ante fallos del modelo en producción (7.19.13)
    7. Requisitos regulatorios y normativos aplicables (8.6.3)
    8. Trazabilidad, reportabilidad y obligaciones de notificación (8.6.7)
    9. Cumplimiento normativo y estándares de la industria (12.1.4)
    10. Propiedad intelectual y licenciamiento de software (12.1.3)
    11. Impacto social y ambiental del software (12.1.12)
    12. Soberanía de datos y cumplimiento regional (12.1.13)
    13. Gestión responsable de IA generativa (12.1.14)

2. Operaciones y resiliencia a nivel empresa
    1. Gestión de SLAs, SLOs y SLIs (11.3.3)
    2. Ejercicios de continuidad operacional y DRP (11.3.8)
    3. Gestión de incidentes de seguridad (11.3.9)
    4. Comunicación durante incidentes críticos (11.3.10)
    5. Madurez de procesos DevSecOps (11.3.11)
    6. Análisis forense y preservación de evidencia técnica (8.5.3)
    7. Comunicación interna y externa durante incidentes (8.5.5)
    8. Planes de continuidad operativa y recuperación de negocio (8.5.6)
    9. Gestión coordinada con legal, compliance y stakeholders críticos (8.5.7)

3. Estrategia de talento y organización
    1. Estrategia de contratación y onboarding técnico (11.2.14)
    2. Escalamiento organizacional y delegación (11.2.15)

4. Innovación y transferencia tecnológica
    1. Innovación responsable, segura y sostenible (12.2.10)
    2. Estrategia de patentes y divulgación científica (12.2.11)
    3. Transferencia tecnológica y escalamiento a producción (12.2.12)
    4. Health checks organizacionales y madurez técnica (12.3.8)
    5. Automatización de controles y reportabilidad (12.3.10)
    6. Preparación para auditorías externas y certificaciones (12.3.12)
    7. Auditoría de seguridad y cumplimiento (organizacional) (12.3.4)
    8. Auditoría de acceso y trazabilidad (organizacional) (12.3.5)
